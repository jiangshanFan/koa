/**
 * 使用REST和使用MVC是类似的，不同的是，提供REST的Controller处理函数最后不调用render()去渲染模板，而是把结果直接用JSON序列化返回给客户端
 * 
 * ***********************************************************************************************************************
 * 
 * 问题一：如何组织URL？
 * 1.通过固定的前缀区分，例如，/static/开头的URL是静态资源文件，类似的，/api/开头的URL是REST API，其他URL是普通的MVC请求
 * 2.对于大型项目，使用不同的子域名也可以区分，但对于中小项目来说配置麻烦，并且随着项目的扩大，将来仍然可以把单域名拆成多域名
 * 
 * ***********************************************************************************************************************
 * 
 * 问题二：如何统一输出REST?
 * 每个异步函数中可能都会有重复的代码，一旦出错可能就会导致浏览器得不到JSON数据，所以可以通过一个middleware给ctx添加一个rest()方法，直接输出JSON数据。
 * 由于我们给所有REST API一个固定的URL前缀/api/，所以，这个middleware还需要根据path来判断当前请求是否是一个REST请求，如果是，我们才给ctx绑定rest()方法。
 * 
 * ***********************************************************************************************************************
 * 
 * 问题三：如何处理错误？
 * 1.当REST API请求出错时，我们如何返回错误信息？
 * 2.当客户端收到REST响应后，如何判断是成功还是错误？
 * 
 * REST架构本身对错误处理并没有统一的规定。实际应用时，各种各样的错误处理机制都有。有的设计得比较合理，有的设计得不合理，导致客户端尤其是手机客户端处理API简直就是噩梦。
 * 
 * 在涉及到REST API的错误时，我们必须先意识到，客户端会遇到两种类型的REST API错误。
 * 1.类似403，404，500等错误，这些错误实际上是HTTP请求可能发生的错误。REST请求只是一种请求类型和响应类型均为JSON的HTTP请求，因此，这些错误在REST请求中也会发生。针对这种类型的错误，客户端除了提示用户“出现了网络错误，稍后重试”以外，并无法获得具体的错误信息。
 * 2.业务逻辑的错误，例如，输入了不合法的Email地址，试图删除一个不存在的Product，等等。这种类型的错误完全可以通过JSON返回给客户端，这样客户端可以根据错误信息提示用户“Email不合法”等，以便用户修复后重新请求API。
 *
 * 问题的关键在于客户端必须能区分出这两种类型的错误。
 * 第一类的错误实际上客户端可以识别，并且我们也无法操控HTTP服务器的错误码。
 * 第二类的错误信息是一个JSON字符串,通过定义错误码识别错误类型
 * 
 * ***********************************************************************************************************************
 * 
 * 问题四：如何定义错误码？
 * REST架构本身同样没有标准的错误码定义，有两种错误码：数字和字符串，强烈建议使用字符串作为错误码。
 * 原因在于，使用数字作为错误码时，API提供者需要维护一份错误码代码说明表，并且，该文档必须时刻与API发布同步，否则，客户端开发者遇到一个文档上没有写明的错误码，就完全不知道发生了什么错误。
 * 我们定义的REST API错误格式如下：
 * {
 *    "code": "错误代码",
 *    "message": "错误描述信息"
 * }
 * 其中，错误代码命名规范为大类:子类，例如，口令不匹配的登录错误代码为auth:bad_password，用户名不存在的登录错误代码为auth:user_not_found。
 * 这样，客户端既可以简单匹配某个类别的错误，也可以精确匹配某个特定的错误。
 * 
 * ***********************************************************************************************************************
 * 
 * 问题五：如何返回错误？
 * 如果一个REST异步函数想要返回错误，一个直观的想法是调用ctx.rest()，这种方式不好，因为控制流程会混乱，而且，错误只能在Controller函数中输出。
 * 更好的方式是异步函数直接用throw语句抛出错误，让middleware去处理错误：
 * user = processLogin(username, password);
 * if (user != null) {
 *    ctx.rest(user);
 * } else {
 *    throw new APIError('auth:user_not_found', 'user not found');
 * }  
 * 这种方式可以在异步函数的任何地方抛出错误，包括调用的子函数内部。
 * 
 **/
module.exports = {
  //这个错误处理的好处在于，不但简化了Controller的错误处理（只需要throw，其他不管），并且，在遇到非APIError的错误时，自动转换错误码为internal: unknown_error。
  //最后，顺便把APIError这个对象export出去。
  APIError: function (code, message) {
    this.code = code || 'internal: unknown_error';
    this.message = message || '';
  },
  restify: (pathPrefix) => {
    // REST API 前缀, 默认为/api/
    pathPrefix = pathPrefix || '/api/';
    return async (ctx, next) => {
      // 是否是REST API前缀？
      if (ctx.request.path.startsWith(pathPrefix)) {
        // 绑定rest()方法
        ctx.rest = (data) => {
          ctx.response.type = 'application/json';
          ctx.response.body = data;
        }
        try {
          await next();
        } catch (e) {
           //受益于async/ await语法，我们在middleware中可以直接用try...catch捕获异常。如果是callback模式，就无法用try...catch捕获，代码结构将混乱得多。
           // 返回错误
          ctx.response.status = 400;
          ctx.response.type = 'application/json';
          ctx.response.body = {
            code: e.code || 'internal: unknown_error',
            message: e.message || ''
          };
        }
      } else {
        await next();
      }
    };
  }
};

/**
 * 这样，任何支持REST的异步函数只需要简单地调用：
 * ctx.rest({
 *    data: 123
 * });
 * 就完成了REST请求的处理。
 */ 


  

